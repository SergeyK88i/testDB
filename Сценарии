
Представим, что у нас есть submissions таблица, и в ней колонка answers_data JSONB, куда мы кладем весь JSON с ответами.

Сложности возникают сразу же:

   1. Валидация:
       * Проблема: Как бэкенд поймет, что JSON-ответ пользователя соответствует структуре шаблона? Что все обязательные поля заполнены? Что типы данных верны?
       * Решение в JSONB: Бэкенд должен будет вручную парсить JSON-ответ, сравнивать его с JSON-структурой шаблона (которую тоже нужно достать и распарсить), и вручную
         проверять каждое поле. Это много кода, подверженного ошибкам.
       * Решение в реляционной схеме: Бэкенд просто проверяет, что для каждого field_id (из fields) есть соответствующая запись в answers.

   2. Версионирование:
       * Проблема: Если структура шаблона меняется (создается новая версия), как бэкенд поймет, что JSON-ответ пользователя соответствует именно той версии шаблона,
         которую он заполнял?
       * Решение в JSONB: Вам придется хранить version_id рядом с answers_data JSONB. Но тогда при проверке вам нужно будет достать version_id, потом достать
         template_versions.structure JSONB для этой версии, и только потом сравнивать.
       * Решение в реляционной схеме: submissions.version_id напрямую ссылается на template_versions.id.

   3. Проверка Модератором (самое сложное):
       * Проблема: Модератор должен утвердить или отклонить отдельные поля внутри JSON-ответа. Как это сделать?
       * Решение в JSONB: Бэкенд должен будет:
           1. Достать answers_data JSONB.
           2. Десериализовать его.
           3. Найти нужное поле внутри объекта.
           4. Изменить его статус валидации и добавить комментарий.
           5. Сериализовать весь JSON обратно и сохранить.
           * Это очень затратно по ресурсам и сложно в реализации.
           * Как модератор будет ссылаться на конкретное поле? По его "пути" в JSON? answers_data.items[0].fields[1].value? Это очень хрупко.
       * Решение в реляционной схеме: У каждого ответа есть свой answers.id. Модератор просто отправляет POST /answers/{answerId}/validate, и бэкенд обновляет одну строку
         в таблице answers. Это просто и надежно.

   4. Отчетность и поиск:
       * Проблема: "Покажи мне все ответы на вопрос 'ФИО' во всех заполнениях".
       * Решение в JSONB: Очень сложный и медленный запрос, который будет парсить JSONB-поля.
       * Решение в реляционной схеме: Простой SELECT * FROM answers WHERE field_id = <ID_поля_ФИО>.

  Вывод:

  Таким образом, хотя "просто положить JSON" кажется легким, сложность не в хранении, а в работе с этими данными. В вашем проекте, где требуется детальная валидация,
  версионирование и гибкий поиск по отдельным элементам, JSONB подход быстро приведет к очень сложной и неэффективной логике на бэкенде.


Почему JSONB сложнее поддерживать, даже если стори-поинты схожи:

   1. Тип сложности:
       * Реляционная схема: Основная сложность сосредоточена на этапе проектирования и начальной реализации связей (создание миграций, продумывание JOIN-ов). После того
         как эта структура создана и протестирована, дальнейшая работа (чтение, запись, обновление) становится предсказуемой и надежной.
       * JSONB схема: Сложность переносится на каждую операцию чтения/записи/обновления данных. Каждый раз, когда нужно что-то сделать с данными внутри JSONB, бэкендеру
         приходится писать код для:
           * Парсинга JSON (десериализации).
           * Ручной валидации данных внутри JSON.
           * Манипуляции с данными внутри JSON.
           * Сериализации обратно в JSON.
           * Это повторяющаяся, рутинная и подверженная ошибкам работа.

   2. Скрытые затраты и риски (которые стори-поинты не всегда полностью отражают):
       * Отладка: Ошибки в данных внутри JSONB гораздо сложнее найти и исправить, чем ошибки в четко структурированных реляционных таблицах.
       * Изменение требований: Если бизнес-требования меняются, и нужно добавить новое поле или изменить логику валидации, это может потребовать переписывания значительной
         части кода, работающего с JSONB, так как нет жесткой схемы.
       * Производительность: Проблемы с производительностью запросов по JSONB могут всплыть позже и потребовать дорогостоящих оптимизаций или даже переписывания части
         системы.
       * Отчетность: Создание новых отчетов по данным, хранящимся внутри JSONB, будет постоянно требовать значительных усилий и написания сложного кода.
       * Гарантии БД: Реляционная БД дает гарантии целостности данных (например, внешний ключ не даст сослаться на несуществующую запись). JSONB не дает таких гарантий, и
         бэкендеру приходится писать больше кода для обеспечения этой целостности, что увеличивает сложность и вероятность ошибок.

  Вывод:

  Таким образом, хотя первоначальная разработка (то, что оценивается стори-поинтами) может быть оценена схожим количеством стори-поинтов, общая стоимость владения 
  (Total Cost of Ownership) для JSONB подхода будет значительно выше из-за постоянных накладных расходов на поддержку, отладку и развитие.




Почему ваш проект с опросником отличается от "идеального" сценария для JSONB:

   1. Структура опросника жестко определена и версионируется:
       * У вас есть четкие "Пункты" и "Поля" с их label, fieldType, isRequired. Эта структура не хаотична, она задается Модератором и должна быть неизменной для каждой
         версии.
       * В JSONB вам пришлось бы хранить эту структуру как JSON, но тогда вы теряете гарантии БД по ее целостности.

   2. Требуется детальная валидация и проверка:
       * Вам нужно проверять каждый ответ на каждое поле. Модератор должен иметь возможность отклонить конкретный ответ на конкретное поле и оставить комментарий.
       * В JSONB это означало бы, что бэкенд должен был бы парсить весь JSON-ответ, находить внутри него нужное поле, менять его статус, добавлять комментарий, а затем
         сериализовать весь JSON обратно. Это очень сложно и подвержено ошибкам.

   3. Связи с другими сущностями:
       * Ответы пользователя (answers) должны быть связаны с конкретными fields (полями), submissions (заполнениями), users (пользователями), assignments (заданиями).
       * В JSONB эти связи пришлось бы реализовывать вручную внутри JSON-документа, что лишает вас всех преимуществ реляционной БД.

   4. Отчетность и поиск:
       * Вам может понадобиться найти "все ответы на вопрос 'ФИО'" или "все отклоненные ответы по полю 'Скан актов'".
       * В JSONB это очень сложные и медленные запросы. В реляционной схеме это простые SELECT по field_id.

==========================================================================
В нашей текущей, полностью реляционной схеме, у нас 12 таблиц:

   1. sources
   2. users
   3. roles
   4. user_roles
   5. templates
   6. template_versions
   7. questionnaire_items
   8. fields
   9. assignments
   10. submissions
   11. answers
   12. audit_logs


Сколько было бы таблиц при JSONB подходе?

  Если бы мы пошли по пути максимального использования JSONB для хранения структуры опросника и ответов, количество таблиц сократилось бы.

  Вот какие таблицы остались бы:

   1. `sources`: (По-прежнему нужна для пользователей и назначений)
   2. `users`: (По-прежнему нужна для аутентификации, назначений, кто сдал)
   3. `roles`: (По-прежнему нужна)
   4. `user_roles`: (По-прежнему нужна)
   5. `templates`: (По-прежнему нужна для общего названия и описания опросника)
   6. `template_versions`: (По-прежнему нужна для версионирования, но теперь в ней была бы колонка structure JSONB, где хранились бы все пункты и поля)
   7. `assignments`: (По-прежнему нужна для связи шаблона, источника и статуса выполнения)
   8. `submissions`: (По-прежнему нужна, но теперь в ней была бы колонка answers_data JSONB, где хранились бы все ответы пользователя)
   9. `audit_logs`: (По-прежнему нужна)

  Какие таблицы были бы исключены:

   * questionnaire_items (ее содержимое переехало бы в template_versions.structure JSONB)
   * fields (ее содержимое переехало бы в template_versions.structure JSONB)
   * answers (ее содержимое переехало бы в submissions.answers_data JSONB)

  Итого: 9 таблиц.

==================================================
Наш сценарий: Модератор Петров (users.id=101) создал опросник "Еженедельный отчет" (templates.id=1, template_versions.id=1). Назначил его "Отделу Маркетинга"
  (sources.id=1) как Задание №1 (assignments.id=1). Пользователь Иванов (users.id=5) из "Отдела Маркетинга" заполнил его (Заполнение №501, submissions.id=501) и сдал.
  Модератор утвердил.

1. `templates` (Шаблоны)

   * Смысл: Это "идея" опросника, его общее название и описание. Это как "пустой бланк" заявления.
   * Пример данных (после Шага 1):

   1     id | name              | description                     | author_id | status    | created_at | updated_at
   2     ---|-------------------|---------------------------------|-----------|-----------|------------|------------
   3     1  | Еженедельный отчет| Отчет о проделанной работе...   | 101       | PUBLISHED | ...        | ...
   * Логика: Это "родитель" для всех версий опросника.

  2. `template_versions` (Версии шаблонов)

   * Смысл: Это конкретный "снимок" структуры опросника на определенный момент времени. Если опросник меняется, создается новая версия.
   * Пример данных (после Шага 1):

   1     id | template_id | version_number | changelog | created_at
   2     ---|-------------|----------------|-----------|------------
   3     1  | 1           | 1              | NULL      | ...
   * Логика: Связан с templates по template_id (колонка template_id в template_versions содержит id из templates). Это "родитель" для пунктов опросника.

  3. `questionnaire_items` (Пункты опросника)

   * Смысл: Это "разделы" или "пункты" внутри конкретной версии опросника.
   * Пример данных (после Шага 1):
   1     id | version_id | title           | display_order | description | ...
   2     ---|------------|-----------------|---------------|-------------|----
   3     10 | 1          | Задачи на неделю| 1             | NULL        | ...
   * Логика: Связан с template_versions по version_id. Это "родитель" для полей.

  4. `fields` (Поля)

   * Смысл: Это конкретные "вопросы" или "поля для ввода" внутри пункта.
   * Пример данных (после Шага 1):

   1     id  | item_id | label         | field_type | is_required | display_order | ...
   2     ----|---------|---------------|------------|-------------|---------------|----
   3     101 | 10      | Текст отчета  | text       | TRUE        | 1             | ...
   4     102 | 10      | Файл отчета   | file       | FALSE       | 2             | ...
   * Логика: Связан с questionnaire_items по item_id. Это "родитель" для ответов.

  5. `assignments` (Задания)

   * Смысл: Это поручение. Связывает "что нужно сделать" (опросник) с "кому это нужно сделать" (источнику) и отслеживает статус этого поручения.
   * Пример данных (после Шага 2, 3, 4, 6):

   1     id | name                      | template_id | source_id | status    | assignee_user_id | due_date | assigned_by_id | ...
   2     ---|---------------------------|-------------|-----------|-----------|------------------|----------|----------------|----
   3     1  | Еженедельный отчет - 15 марта | 1           | 1         | COMPLETED | 5                | NULL     | 101            | ...
   * Логика:
       * template_id: Ссылается на templates.id (какой опросник назначен).
       * source_id: Ссылается на sources.id (кому поручено).
       * status: Отслеживает жизненный цикл поручения (LOCKED, PENDING, IN_PROGRESS, COMPLETED, CANCELLED).
       * assignee_user_id: Ссылается на users.id (кто конкретно выполняет поручение).
       * Это и есть связь шаблона, источника и статуса выполнения.

  6. `submissions` (Заполнения)

   * Смысл: Конкретная "сданная работа" пользователя по одному Заданию. Это как "заполненный бланк".
   * Пример данных (после Шага 5, 6):

   1     id  | assignment_id | version_id | user_id | status   | submitted_at | reviewed_at | ...
   2     ----|---------------|------------|---------|----------|--------------|-------------|----
   3     501 | 1             | 1          | 5       | APPROVED | ...          | ...         | ...
   * Логика:
       * Связан с assignments по assignment_id (к какому поручению относится).
       * Связан с template_versions по version_id (какую версию опросника заполнили).
       * Связан с users по user_id (кто заполнил).

  7. `answers` (Ответы)

   * Смысл: Конкретный ответ на конкретный вопрос (поле) в сданной работе.
   * Пример данных (после Шага 5, 6):

   1     id  | submission_id | field_id | text_answer                     | file_path   | original_filename | validation_status | moderator_comment | ...
   2     ----|---------------|----------|---------------------------------|-------------|-------------------|-------------------|-------------------|----
   3     801 | 501           | 101      | На этой неделе выполнено 5 задач.| NULL        | NULL              | APPROVED          | NULL              | ...
   4     802 | 501           | 102      | NULL                            | abc-123.pdf | отчет.pdf         | APPROVED          | NULL              | ...
   * Логика:
       * Связан с submissions по submission_id (к какой работе относится).
       * Связан с fields по field_id (на какой вопрос ответ).

  ---

  Надеюсь, этот детальный разбор с примерами данных и акцентом на связи помог вам увидеть смысл каждой таблицы и их взаимодействие. Теперь, когда вы видите, как данные
  "живут" в базе, мы можем перейти к тому, как API-эндпоинты будут "дергать" эти операции.

======================================================

Вы абсолютно правильно понимаете иерархию: questionnaire_items — это пункты (разделы), а fields — это конкретные вопросы внутри этих пунктов.

  Когда пользователь начинает заполнять эти поля (то есть отвечать на вопросы), его данные ложатся в таблицу `answers`.

  Вот как это происходит:

   1. `questionnaire_items` (Пункты):
       * id = 10, title = "К10: Дайте оценку"
       * id = 11, title = "К11: Расскажите об источнике"

   2. `fields` (Поля внутри пунктов):
       * Для пункта "К10: Дайте оценку":
           * id = 101, item_id = 10, label = "Оценка (от 1 до 5)", field_type = text
       * Для пункта "К11: Расскажите об источнике":
           * id = 102, item_id = 11, label = "Наименование источника", field_type = text
           * id = 103, item_id = 11, label = "Описание деятельности", field_type = text
           * id = 104, item_id = 11, label = "Логотип источника", field_type = file

   3. `answers` (Куда ложатся данные пользователя):
       * Когда пользователь заполняет форму, его ответы записываются в таблицу answers. Каждая запись в answers жестко привязана к конкретному полю (`fields.id`) через
         колонку answers.field_id.

       * Пример заполнения:
           * Ответ на поле "Оценка (от 1 до 5)":
               * answers.id = 801, submission_id = 501, field_id = 101, text_answer = "5", validation_status = 'PENDING'
           * Ответ на поле "Наименование источника":
               * answers.id = 802, submission_id = 501, field_id = 102, text_answer = "Тульский филиал", validation_status = 'PENDING'
           * Ответ на поле "Логотип источника":
               * answers.id = 803, submission_id = 501, field_id = 104, file_path = "logo_tula.png", original_filename = "логотип.png", validation_status = 'PENDING'

  Таким образом, бэкенд всегда знает, какой ответ (из answers) относится к какому вопросу (из fields), который, в свою очередь, находится в каком пункте (из
  questionnaire_items).

=================================================
Когда версия меняется, в таблице template_versions просто добавляется новая строка с новым `id`.

  Давайте посмотрим на примере:

  Исходная ситуация:

  У нас есть шаблон "Еженедельный отчет" (templates.id = 1). Его текущая версия — template_versions.id = 1, version_number = 1.

  Таблица `template_versions` (ДО изменения):

   1 id | template_id | version_number | changelog | created_at
   2 ---|-------------|----------------|-----------|------------
   3 1  | 1           | 1              | NULL      | 2026-03-01

  Процесс изменения версии:

   1. Действие Модератора: Модератор решает изменить опросник "Еженедельный отчет" (например, добавить новое поле "Комментарии"). Он нажимает в UI "Создать новую версию".

   2. Что делает бэкенд:
       * Находит текущий максимальный version_number для template_id = 1 (это 1).
       * Инкрементирует его: 1 + 1 = 2.
       * Выполняет `INSERT` в `template_versions`:
           * template_id: 1 (этот ID остается тем же, так как это тот же родительский шаблон)
           * version_number: 2 (это новый, инкрементированный номер версии)
           * changelog: "Добавлено поле 'Комментарии'" (если Модератор указал)
           * id: 2 (база данных генерирует новый уникальный id для этой новой записи версии)

   3. Что происходит дальше (важно для понимания):
       * После создания этой новой записи в template_versions (с id=2, version_number=2), бэкенд также создает НОВЫЕ записи в questionnaire_items и fields, которые
         отражают новую структуру опросника. Все эти новые пункты и поля будут ссылаться на template_versions.id = 2.

  Таблица `template_versions` (ПОСЛЕ изменения):

   1 id | template_id | version_number | changelog                     | created_at
   2 ---|-------------|----------------|-------------------------------|------------
   3 1  | 1           | 1              | NULL                          | 2026-03-01
   4 2  | 1           | 2              | Добавлено поле 'Комментарии' | 2026-03-08

  Таким образом, каждая строка в template_versions представляет собой уникальный, неизменный "снимок" структуры опросника на определенный момент времени. Старые версии
  остаются в базе данных, и на них могут ссылаться старые submissions. Новые submissions будут ссылаться на новую версию.

=================================================
Пример: Опрос по проекту "Альфа"

  Сценарий:
   * Модератор: Петров Петр (users.id = 101)
   * Источник: "Отдел Маркетинга" (sources.id = 1)
   * Пользователь: Иванов Иван (users.id = 5)

  Опросник "Опрос по проекту 'Альфа'":
   * Пункт 1: "Общая информация"
       * Поле 1: "Ваше ФИО" (текст)
       * Поле 2: "Дата заполнения" (текст)
   * Пункт 2: "Отчетность"
       * Поле 3: "Статус проекта" (текст)
       * Поле 4: "Прикрепите отчет" (файл)

  ---

  Состояние таблиц после заполнения и утверждения

  (Для краткости показаны только ключевые колонки и данные, относящиеся к сценарию)

  1. `sources` (Источники)
   * Смысл: Кто такой "Отдел Маркетинга".
   * Связь: users.source_id ссылается на sources.id.
   1 id | name
   2 ---|------------------
   3 1  | Отдел Маркетинга

  2. `users` (Пользователи)
   * Смысл: Кто такие Петров и Иванов.
   * Связь: assignments.assigned_by_id, assignments.assignee_user_id, submissions.user_id ссылаются на users.id.
   1 id  | full_name      | source_id | ...
   2 ----|----------------|-----------|----
   3 5   | Иванов Иван    | 1         | ...
   4 101 | Петров Петр    | NULL      | ...

  3. `templates` (Шаблоны)
   * Смысл: Общая идея опросника "Опрос по проекту 'Альфа'".
   * Связь: template_versions.template_id ссылается на templates.id.

   1 id | name                  | author_id | status    | ...
   2 ---|-----------------------|-----------|-----------|----
   3 10 | Опрос по проекту 'Альфа'| 101       | PUBLISHED | ...

  4. `template_versions` (Версии шаблонов)
   * Смысл: Конкретная версия опросника "Опрос по проекту 'Альфа'".
   * Связь: questionnaire_items.version_id и submissions.version_id ссылаются на template_versions.id.

   1 id  | template_id | version_number | ...
   2 ----|-------------|----------------|----
   3 100 | 10          | 1              | ...

  5. `questionnaire_items` (Пункты опросника)
   * Смысл: Разделы внутри версии опросника.
   * Связь: fields.item_id ссылается на questionnaire_items.id.

   1 id   | version_id | title             | ...
   2 -----|------------|-------------------|----
   3 1000 | 100        | Общая информация  | ...
   4 1001 | 100        | Отчетность        | ...

  6. `fields` (Поля)
   * Смысл: Конкретные вопросы внутри пунктов.
   * Связь: answers.field_id ссылается на fields.id.

   1 id    | item_id | label             | field_type | ...
   2 ------|---------|-------------------|------------|----
   3 10000 | 1000    | Ваше ФИО          | text       | ...
   4 10001 | 1000    | Дата заполнения   | text       | ...
   5 10002 | 1001    | Статус проекта    | text       | ...
   6 10003 | 1001    | Прикрепите отчет  | file       | ...

  7. `assignments` (Задания)
   * Смысл: Поручение "Отделу Маркетинга" заполнить "Опрос по проекту 'Альфа'".
   * Связь: submissions.assignment_id ссылается на assignments.id.

   1 id  | name               | template_id | source_id | status    | assignee_user_id | assigned_by_id | ...
   2 ----|--------------------|-------------|-----------|-----------|------------------|----------------|----
   3 100 | Опрос Альфа - Март | 10          | 1         | COMPLETED | 5                | 101            | ...

  8. `submissions` (Заполнения)
   * Смысл: Сданная работа Иванова по Заданию №100.
   * Связь: answers.submission_id ссылается на submissions.id.

   1 id    | assignment_id | version_id | user_id | status   | ...
   2 ------|---------------|------------|---------|----------|----
   3 1000  | 100           | 100        | 5       | APPROVED | ...

  9. `answers` (Ответы)
   * Смысл: Конкретные ответы Иванова на каждый вопрос.
   * Связь: Это "конечная" таблица в цепочке данных пользователя.

   1 id     | submission_id | field_id | text_answer     | file_path          | original_filename | validation_status | ...
   2 -------|---------------|----------|-----------------|--------------------|-------------------|-------------------|----
   3 100000 | 1000          | 10000    | Иванов Иван     | NULL               | NULL              | APPROVED          | ...
   4 100001 | 1000          | 10001    | 2026-03-15      | NULL               | NULL              | APPROVED          | ...
   5 100002 | 1000          | 10002    | В процессе      | NULL               | NULL              | APPROVED          | ...
   6 100003 | 1000          | 10003    | alpha_report.pdf| Отчет_Альфа.pdf    | APPROVED          | ...

  ---

  Как все таблицы связываются между собой:

   * `answers` (ответы) привязаны к `submissions` (сданной работе) по submission_id.
   * `answers` (ответы) привязаны к `fields` (вопросам) по field_id.
   * `submissions` (сданная работа) привязана к `assignments` (поручению) по assignment_id.
   * `submissions` (сданная работа) привязана к `template_versions` (версии опросника) по version_id.
   * `assignments` (поручение) привязано к `templates` (общему опроснику) по template_id.
   * `assignments` (поручение) привязано к `sources` (источнику) по source_id.
   * `fields` (вопросы) привязаны к `questionnaire_items` (пунктам) по item_id.
   * `questionnaire_items` (пункты) привязаны к `template_versions` (версии опросника) по version_id.
   * `template_versions` (версии опросника) привязаны к `templates` (общему опроснику) по template_id.

  Эта цепочка связей позволяет бэкенду собрать полную картину: от конкретного ответа до того, кто его дал, на какой вопрос, в каком пункте, в какой версии какого
  опросника, по какому поручению и для какого источника.

======================================================================
