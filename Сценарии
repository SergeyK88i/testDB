Клиентский путь: Взаимодействие ролей, Frontend и Backend (ФИНАЛЬНАЯ ВЕРСИЯ)

  Этап 1: Создание и Публикация Опросника (Роль: Модератор)

   1. Действие Модератора (UI): Модератор заходит в систему, переходит в раздел "Шаблоны", нажимает "Создать новый опросник". Заполняет название,
      описание, добавляет пункты и поля через конструктор формы. Нажимает "Сохранить".
       * Что делает Frontend: Собирает данные из формы и отправляет их на бэкенд через POST /api/v1/templates.
       * Что делает Backend: Создает записи в таблицах templates, template_versions, questionnaire_items, fields, связывая их между собой через ID.
         Возвращает id созданного шаблона.
       * Что получает Frontend: Подтверждение создания шаблона и его id. Отображает шаблон в списке.

   2. Действие Модератора (UI): Модератор решает, как назначить опросник.

       * Вариант А: Автоматическое назначение всем источникам при публикации.
           * Действие Модератора (UI): Модератор находит созданный шаблон в списке, нажимает "Опубликовать", выбирает опцию "Назначить всем
             источникам" и подтверждает.
           * Что делает Frontend: Отправляет POST /api/v1/templates/{templateId}/publish с флагом assignToAllSources: true.
           * Что делает Backend: Обновляет status шаблона на PUBLISHED. Затем, делает `SELECT id FROM sources` (получает список всех источников в 
             системе) и для каждого source_id из этого списка создает новую запись в таблице assignments со статусом LOCKED, ссылаясь на template_id
             и source_id. Возвращает подтверждение.
           * Что получает Frontend: Подтверждение публикации и создания заданий.

       * Вариант Б: Ручное назначение конкретным источникам.
           * Действие Модератора (UI): Модератор находит созданный шаблон в списке, нажимает "Опубликовать" (без опции авто-назначения). Затем
             переходит в раздел "Задания", нажимает "Создать Задание", выбирает опросник, выбирает конкретные источники, вводит название Задания и
             подтверждает.
           * Что делает Frontend (для публикации): Отправляет POST /api/v1/templates/{templateId}/publish (без флага assignToAllSources).
           * Что делает Backend (для публикации): Обновляет status шаблона на PUBLISHED. Возвращает подтверждение.
           * Что получает Frontend (для публикации): Подтверждение публикации.
           * Что делает Frontend (для ручного назначения): Отправляет POST /api/v1/assignments с templateId, массивом sourceIds (выбранные вручную),
             name Задания.
           * Что делает Backend (для ручного назначения): Для каждого sourceId из массива создает запись в таблице assignments со статусом LOCKED.
             Возвращает подтверждение.
           * Что получает Frontend (для ручного назначения): Подтверждение создания заданий.

  Этап 2: Активация Заданий (Роль: Модератор)

   1. Действие Модератора (UI): Модератор переходит в раздел "Задания", видит список всех заданий, в том числе LOCKED. Выбирает несколько заданий
      (например, для "Тульского филиала") и нажимает "Активировать".
       * Что делает Frontend: Отправляет POST /api/v1/assignments/unlock с массивом assignmentIds выбранных заданий.
       * Что делает Backend: Обновляет status выбранных заданий с LOCKED на PENDING в таблице assignments. Возвращает подтверждение.
       * Что получает Frontend: Подтверждение разблокировки. Обновляет статус заданий в UI.

  Этап 3: Пользователь видит Задания и берет одно в работу (Роль: Пользователь)


   1. Действие Пользователя (UI): Пользователь (Иванов) заходит в систему, открывает страницу "Мои задания".
       * Что делает Frontend: Отправляет GET /api/v1/assignments/my.
       * Что делает Backend: Находит source_id пользователя, выбирает все assignments для этого источника, JOIN с templates для названия. Возвращает
         список заданий.
       * Что получает Frontend: Список заданий. Отображает их, помечая LOCKED как неактивные, PENDING как активные.
   2. Действие Пользователя (UI): Иванов видит Задание "Квартальный отчет" со статусом PENDING. Нажимает "Начать работу".
       * Что делает Frontend: Отправляет POST /api/v1/assignments/{assignmentId}/claim.
       * Что делает Backend: Обновляет assignments.status на IN_PROGRESS и прописывает assignee_user_id (ID Иванова). Возвращает обновленное
         задание.
       * Что получает Frontend: Обновленный статус задания в UI.

  Этап 4: Заполнение Опросника (Роль: Пользователь)

   1. Действие Пользователя (UI): Иванов открывает форму опросника.
       * Что делает Frontend: Отправляет GET /api/v1/templates/{templateId}/versions/{versionNumber}.
       * Что делает Backend: Собирает полную иерархическую структуру формы из template_versions, questionnaire_items, fields. Возвращает эту
         структуру.
       * Что получает Frontend: Полную структуру формы. Динамически отрисовывает форму на основе полученного JSON.
   2. Действие Пользователя (UI): Иванов заполняет текстовые поля. Доходит до поля "Файл отчета" и загружает отчет.pdf.
       * Что делает Frontend: Отправляет POST /api/v1/files/upload.
       * Что делает Backend: Сохраняет файл на диск, возвращает filePath и originalFilename.
       * Что получает Frontend: filePath и originalFilename. Отображает имя файла, сохраняет filePath в состоянии формы.
   3. Действие Пользователя (UI): Иванов нажимает "Отправить".
       * Что делает Frontend: Собирает все данные из формы (включая filePath для файлов) и отправляет POST /api/v1/submissions.
       * Что делает Backend: Создает записи в submissions (ссылаясь на assignment_id, version_id, user_id) и множество записей в answers (ссылаясь
         на submissions.id и fields.id). Возвращает submission_id и статус.
       * Что получает Frontend: Подтверждение. Отображает сообщение об успешной отправке, перенаправляет пользователя.

  Этап 5: Проверка и Отклонение (Роль: Модератор)

   1. Действие Модератора (UI): Модератор видит, что появилась новая работа на проверку. Открывает ее.
       * Что делает Frontend: Отправляет GET /api/v1/submissions/{submissionId}.
       * Что делает Backend: Собирает полную картину заполненной формы из submissions, answers, fields, questionnaire_items, users. Для файловых
         ответов конструирует downloadUrl (ссылку на безопасный эндпоинт скачивания). Возвращает этот JSON.
       * Что получает Frontend: Полную картину заполненной формы. Отображает ее.
   2. Действие Модератора (UI): Модератор отклоняет ответ на "Файл отчета", пишет комментарий.
       * Что делает Frontend: Отправляет POST /api/v1/answers/{answerId}/validate.
       * Что делает Backend: Обновляет answers.validation_status на REJECTED и moderator_comment. Возвращает обновленный ответ.
       * Что получает Frontend: Обновляет UI для этого ответа.
   3. Действие Модератора (UI): Модератор нажимает "Отправить на доработку" для всей работы.
       * Что делает Frontend: Отправляет PUT /api/v1/submissions/{submissionId}.
       * Что делает Backend: Обновляет submissions.status на REJECTED. Возвращает подтверждение.
       * Что получает Frontend: Обновляет UI.

  Этап 6: Исправление и Повторная Отправка (Роль: Пользователь)


   1. Действие Пользователя (UI): Пользователь открывает работу, видит комментарии.
       * Что делает Frontend: Отправляет GET /api/v1/submissions/{submissionId}.
       * Что делает Backend: Возвращает форму с REJECTED статусами и комментариями.
       * Что получает Frontend: Отображает форму, подсвечивает ошибки.
   2. Действие Пользователя (UI): Загружает новый, исправленный файл.
       * Что делает Frontend: Отправляет POST /api/v1/files/upload.
       * Что делает Backend: Сохраняет файл на диск, возвращает filePath.
       * Что получает Frontend: filePath нового файла. Обновляет состояние формы.
   3. Действие Пользователя (UI): Нажимает "Отправить".
       * Что делает Frontend: Отправляет PUT /api/v1/submissions/{submissionId} (с обновленными answers).
       * Что делает Backend: Обновляет answers (меняет file_path, сбрасывает validation_status на PENDING, очищает moderator_comment). Обновляет
         submissions.status на SUBMITTED. Возвращает подтверждение.
       * Что получает Frontend: Подтверждение.

  Этап 7: Финальное Утверждение (Роль: Модератор)

   1. Действие Модератора (UI): Модератор повторно проверяет работу.
       * Что делает Frontend: Отправляет GET /api/v1/submissions/{submissionId}.
       * Что делает Backend: Возвращает форму с PENDING статусами.
       * Что получает Frontend: Отображает форму.
   2. Действие Модератора (UI): Модератор утверждает исправленный ответ.
       * Что делает Frontend: Отправляет POST /api/v1/answers/{answerId}/validate.
       * Что делает Backend: Обновляет answers.validation_status на APPROVED. Возвращает обновленный ответ.
       * Что получает Frontend: Обновляет UI.
   3. Действие Модератора (UI): Модератор утверждает всю работу.
       * Что делает Frontend: Отправляет PUT /api/v1/submissions/{submissionId}.
       * Что делает Backend: Обновляет submissions.status на APPROVED. Обновляет assignments.status на COMPLETED. Возвращает подтверждение.
       * Что получает Frontend: Подтверждение.
================================================================================================
ТЗ

 Epic 2: `[MODERATOR]` - Управление жизненным циклом опросников

   * Задача 2.1 (Backend): API для управления шаблонами (CRUD).
       * Что внутри:
           * Создать/обновить модели данных (ORM) для таблиц templates, template_versions, questionnaire_items, fields.
           * Реализовать контроллеры/обработчики для эндпоинтов:
               * POST /api/v1/templates (создание шаблона с иерархией пунктов/полей)
               * GET /api/v1/templates (список шаблонов)
               * GET /api/v1/templates/{templateId} (детали шаблона)
               * PUT /api/v1/templates/{templateId} (обновление шаблона)
               * DELETE /api/v1/templates/{templateId} (архивирование шаблона)
               * POST /api/v1/templates/{templateId}/versions (создание новой версии)
               * GET /api/v1/templates/{templateId}/versions/{versionNumber} (получение структуры версии)
           * Написать логику для сохранения и извлечения данных, используя ORM, точно зная, какие поля из запроса куда мапятся в БД.
           * Обеспечить правильную обработку ошибок и валидацию данных.
           * Написать юнит-тесты для реализованного функционала.
       * Зависимости: Задача 1.1, Задача 1.2.

   * Задача 2.2 (Backend): API для управления назначениями (Assignments).
       * Что внутри:
           * Создать/обновить модели данных (ORM) для таблицы assignments.
           * Реализовать контроллеры/обработчики для эндпоинтов:
               * POST /api/v1/templates/{templateId}/publish (публикация с авто-назначением)
               * POST /api/v1/assignments (ручное назначение)
               * POST /api/v1/assignments/unlock (массовая разблокировка)
               * POST /api/v1/assignments/{assignmentId}/claim (взятие задания в работу)
               * GET /api/v1/assignments/my (задания для текущего пользователя)
               * GET /api/v1/assignments (все задания для модератора)
               * PUT /api/v1/assignments/{assignmentId} (изменение статуса, например, CANCELLED)
           * Написать логику маппинга JSON в БД.
           * Обеспечить правильную обработку ошибок и валидацию данных.
           * Написать юнит-тесты для реализованного функционала.
       * Зависимости: Задача 2.1.

   * Задача 2.3 (Frontend): UI конструктора опросников.
       * Что внутри:
           * Разработать страницы/компоненты для модератора:
               * Список шаблонов (GET /templates).
               * Форма создания/редактирования шаблона с динамическим добавлением/удалением пунктов и полей (POST /templates, PUT /templates).
               * Функционал публикации шаблона (POST /templates/{templateId}/publish).
               * Просмотр версий шаблона (GET /templates/{templateId}/versions/{versionNumber}).
           * Интегрировать с соответствующими API-эндпоинтами.
           * Написать UI-тесты.
       * Зависимости: Задача 1.4, Задача 2.1.

   * Задача 2.4 (Frontend): UI для управления назначениями.
       * Что внутри:
           * Разработать страницы/компоненты для модератора:
               * Список всех заданий (GET /assignments).
               * Функционал фильтрации и поиска заданий.
               * Кнопки для разблокировки заданий (POST /assignments/unlock).
               * Форма для ручного назначения заданий (POST /assignments).
           * Интегрировать с соответствующими API-эндпоинтами.
           * Написать UI-тесты.
       * Зависимости: Задача 1.4, Задача 2.2.

  Epic 3: `[USER]` - Функционал заполнения и проверки

   * Задача 3.1 (Backend): API для загрузки файлов (Upload).
       * Что внутри:
           * Реализовать эндпоинт POST /api/v1/files/upload.
           * Логика: При получении multipart/form-data запроса:
               1. Сгенерировать уникальное имя файла (например, UUID + расширение).
               2. Сохранить файл на диск в папку /var/data/questionnaire_uploads.
               3. Вернуть фронтенду JSON с filePath (уникальное имя) и originalFilename (исходное имя файла).
           * Обеспечить правильную обработку ошибок (например, превышение размера файла, недопустимый тип файла).
           * Написать юнит-тесты.
       * Зависимости: Задача 1.1.


      * Задача 3.2 (Backend): API для отправки `submissions` и безопасной выгрузки файлов (Download).
       * Что внутри:
           * Создать/обновить модели данных (ORM) для таблиц submissions, answers.
           * Реализовать контроллеры/обработчики для следующих эндпоинтов:
               * POST /api/v1/submissions:
                   * Логика: Создать запись в submissions (используя assignmentId, versionId, userId). Затем в цикле для каждого ответа из запроса
                     создать запись в answers (используя submissionId, fieldId, textAnswer или filePath/originalFilename).
               * GET /api/v1/submissions/{submissionId}:
                   * Логика: Собрать сложный JSON-объект, объединяя данные из submissions, answers, fields, questionnaire_items, users. Для файловых
                     ответов конструировать downloadUrl (ссылку на GET /api/v1/submissions/{submissionId}/answers/{answerId}/file).
               * PUT /api/v1/submissions/{submissionId}:
                   * Логика: Обновить submissions.status. Затем в цикле обновить записи в answers (сбросить validation_status на PENDING, обновить
                     textAnswer или filePath/originalFilename).
               * POST /api/v1/answers/{answerId}/validate:
                   * Логика: Обновить answers.validation_status и moderator_comment для конкретного ответа.
               * GET /api/v1/submissions/{submissionId}/answers/{answerId}/file:
                   * Логика: Проверить аутентификацию и авторизацию пользователя (имеет ли он право на доступ к этому файлу). Если права есть,
                     прочитать файл с диска по file_path из БД и потоково передать его клиенту.
           * Написать логику маппинга JSON в БД.
           * Обеспечить правильную обработку ошибок и валидацию данных.
           * Написать юнит-тесты.
       * Зависимости: Задача 1.1, Задача 3.1.

   * Задача 3.3 (Frontend): UI для заполнения опросника.
       * Что внутри:
           * Разработать UI для пользователя:
               * Страница со списком его заданий (GET /assignments/my).
               * Компонент для динамического рендеринга формы опросника на основе JSON-структуры (GET 
                 /templates/{templateId}/versions/{versionNumber}).
               * Логика загрузки файлов (POST /files/upload) и отображения их статуса.
               * Логика сбора данных из формы и отправки на POST /submissions.
               * Логика "взятия в работу" задания (POST /assignments/{assignmentId}/claim).
           * Написать UI-тесты.
       * Зависимости: Задача 1.4, Задача 2.2, Задача 3.1, Задача 3.2.

   * Задача 3.4 (Frontend): UI для проверки опросника.
       * Что внутри:
           * Разработать UI для модератора:
               * Страница со списком работ, ожидающих проверки (GET /submissions).
               * Экран детального просмотра заполненной работы (GET /submissions/{submissionId}).
               * Отображение ответов, комментариев, статусов валидации.
               * Функционал безопасного скачивания файлов (GET /api/v1/submissions/{submissionId}/answers/{answerId}/file).
               * Кнопки для утверждения/отклонения отдельных ответов (POST /answers/{answerId}/validate) и всей работы (PUT 
                 /submissions/{submissionId}).
           * Написать UI-тесты.
       * Зависимости: Задача 1.4, Задача 3.2.

  Epic 4: `[DEVOPS]` - Настройка Nginx и развертывание

   * Задача 4.1 (DevOps): Настройка Nginx и окружений.
       * Что внутри:
           * Настроить Nginx для проксирования всех запросов /api/v1/ на бэкенд.
           * Настроить CI/CD (Continuous Integration/Continuous Deployment) для автоматической сборки и развертывания Backend и Frontend приложений.
           * Подготовить тестовые и продуктивные окружения.
       * Зависимости: Задача 1.1, Задача 1.3.

  Epic 5: `[ADMIN]` - Аудит

   * Задача 5.1 (Backend): API для аудита.
       * Что внутри:
           * Создать/обновить модели данных (ORM) для таблицы audit_logs.
           * Реализовать эндпоинт GET /api/v1/audit-logs.
           * Встроить логику записи событий в audit_logs в другие API-эндпоинты (например, при создании шаблона, смене статуса задания).
           * Написать юнит-тесты.
       * Зависимости: Задача 1.1.

   * Задача 5.2 (Frontend): UI для аудита.
       * Что внутри:
           * Разработать UI для администратора: страница для просмотра журнала событий с фильтрацией и пагинацией.
           * Интегрировать с GET /api/v1/audit-logs.
           * Написать UI-тесты.
       * Зависимости: Задача 1.4, Задача 5.1.

 




================================================================================================
Полная спецификация API (с примерами JSON)

  Общие принципы
   * Базовый URL: /api/v1
   * Аутентификация: Все защищенные эндпоинты требуют токен в заголовке Authorization: Bearer <JWT_TOKEN>.
   * Формат данных: application/json

  ---

  1. Аутентификация (`/auth`)

   * `POST /auth/login`
       * Описание: Аутентификация пользователя по email и паролю.
       * Роль: ANY
       * Пример запроса:

   1         {
   2           "email": "moderator@example.com",
   3           "password": "password123"
   4         }
       * Пример ответа (200 OK):

   1         {
   2           "accessToken":
     "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMe
     Jf36POk6yJV_adQssw5c"
   3         }
       * Логика бэкенда: Проверяет учетные данные, генерирует JWT токен.

   * `POST /auth/register`
       * Описание: Регистрация нового пользователя в системе.
       * Роль: ANY (или ADMIN, в зависимости от бизнес-логики)
       * Пример запроса:

   1         {
   2           "email": "newuser@example.com",
   3           "password": "securepassword",
   4           "fullName": "Новый Пользователь",
   5           "sourceId": 10 // ID источника, к которому привязан пользователь
   6         }
       * Пример ответа (201 Created):

   1         {
   2           "id": 15,
   3           "email": "newuser@example.com",
   4           "fullName": "Новый Пользователь",
   5           "sourceId": 10
   6         }
       * Логика бэкенда: Создает запись в users, хеширует пароль, назначает роль USER по умолчанию.

   * `GET /auth/me`
       * Описание: Получение информации о текущем авторизованном пользователе.
       * Роль: USER
       * Пример ответа (200 OK):
   1         {
   2           "id": 5,
   3           "fullName": "Иванов Иван Иванович",
   4           "email": "ivanov@example.com",
   5           "sourceId": 1,
   6           "roles": ["USER"]
   7         }
       * Логика бэкенда: Извлекает userId из JWT токена, делает SELECT из users и user_roles.

  ---

  2. Шаблоны (`/templates`)

   * `POST /templates`
       * Описание: Создание нового шаблона опросника и его первой версии в статусе DRAFT.
       * Роль: MODERATOR
       * Пример запроса:

    1         {
    2           "name": "Еженедельный отчет по KPI",
    3           "description": "Отчет о выполнении KPI за прошлую неделю.",
    4           "items": [
    5             {
    6               "title": "Ключевые метрики",
    7               "display_order": 1,
    8               "fields": [
    9                 { "label": "Выполнено задач", "fieldType": "text", "isRequired": true, "display_order": 1 },
   10                 { "label": "Просрочено задач", "fieldType": "text", "isRequired": true, "display_order": 2 }
   11               ]
   12             }
   13           ]
   14         }
       * Пример ответа (201 Created):

   1         {
   2           "id": 3,
   3           "name": "Еженедельный отчет по KPI",
   4           "status": "DRAFT",
   5           "latestVersion": 1
   6         }
       * Логика бэкенда: INSERT в templates, template_versions, questionnaire_items, fields (как подробно описано в Шаге 1 сценария).

   * `GET /templates`
       * Описание: Получение списка всех созданных шаблонов.
       * Роль: MODERATOR
       * Пример ответа (200 OK):

    1         [
    2           {
    3             "id": 1,
    4             "name": "Еженедельный отчет",
    5             "status": "PUBLISHED",
    6             "latestVersion": 1,
    7             "author": { "id": 101, "fullName": "Петров Петр" }
    8           },
    9           {
   10             "id": 3,
   11             "name": "Еженедельный отчет по KPI",
   12             "status": "DRAFT",
   13             "latestVersion": 1,
   14             "author": { "id": 101, "fullName": "Петров Петр" }
   15           }
   16         ]
       * Логика бэкенда: SELECT из templates, JOIN с users для автора, JOIN с template_versions для latestVersion.


   * `GET /templates/{templateId}`
       * Описание: Получение детальной информации об одном шаблоне, включая список его версий.
       * Роль: MODERATOR
       * Пример ответа (200 OK):

    1         {
    2           "id": 1,
    3           "name": "Еженедельный отчет",
    4           "description": "Отчет о проделанной работе за неделю",
    5           "status": "PUBLISHED",
    6           "author": { "id": 101, "fullName": "Петров Петр" },
    7           "versions": [
    8             { "id": 1, "versionNumber": 1, "createdAt": "2026-03-01T10:00:00Z" },
    9             { "id": 2, "versionNumber": 2, "changelog": "Добавлено поле 'Комментарии'", "createdAt": "2026-03-08T10:00:00Z" }
   10           ]
   11         }
       * Логика бэкенда: SELECT из templates, JOIN с users, SELECT из template_versions для этого шаблона.

   * `PUT /templates/{templateId}`
       * Описание: Обновление основной информации шаблона (имя, описание).
       * Роль: MODERATOR
       * Пример запроса:

   1         {
   2           "name": "Еженедельный отчет (обновлено)",
   3           "description": "Обновленное описание."
   4         }
       * Пример ответа (200 OK): (Обновленный объект шаблона).
       * Логика бэкенда: UPDATE templates.

   * `DELETE /templates/{templateId}`
       * Описание: Архивирование шаблона (меняет статус на ARCHIVED).
       * Роль: MODERATOR
       * Пример ответа (204 No Content): Пустой ответ.
       * Логика бэкенда: UPDATE templates SET status = 'ARCHIVED'.

   * `POST /templates/{templateId}/publish`
       * Описание: Публикация шаблона с возможностью автоматического назначения всем источникам.
       * Роль: MODERATOR
       * Пример запроса:
   1         {
   2           "assignToAllSources": true
   3         }
       * Пример ответа (200 OK):

   1         {
   2           "success": true,
   3           "message": "Шаблон опубликован. Создано 15 заданий со статусом LOCKED."
   4         }
       * Логика бэкенда: UPDATE templates.status на PUBLISHED. Если assignToAllSources = true, то SELECT из sources и INSERT в assignments для
         каждого источника.

   * `POST /templates/{templateId}/versions`
       * Описание: Создание новой версии опубликованного шаблона.
       * Роль: MODERATOR
       * Пример запроса:

    1         {
    2           "changelog": "Добавлено поле 'Комментарии' в пункт 'Общие сведения'.",
    3           "items": [
    4             {
    5               "title": "Общие сведения",
    6               "display_order": 1,
    7               "fields": [
    8                 { "label": "Название", "fieldType": "text", "isRequired": true, "display_order": 1 },
    9                 { "label": "Комментарии", "fieldType": "text", "isRequired": false, "display_order": 2 }
   10               ]
   11             }
   12           ]
   13         }
       * Пример ответа (201 Created):

   1         {
   2           "id": 2,
   3           "versionNumber": 2,
   4           "templateId": 1
   5         }
       * Логика бэкенда: SELECT MAX(version_number) для шаблона, INSERT в template_versions (с инкрементированным номером версии), INSERT в
         questionnaire_items и fields для новой версии.

   * `GET /templates/{templateId}/versions/{versionNumber}`
       * Описание: Получение полной структуры конкретной версии шаблона для рендеринга формы.
       * Роль: USER, MODERATOR
       * Пример ответа (200 OK):


    1         {
    2           "id": 1,
    3           "versionNumber": 1,
    4           "templateId": 1,
    5           "name": "Еженедельный отчет",
    6           "items": [
    7             {
    8               "id": 10,
    9               "title": "Задачи на неделю",
   10               "display_order": 1,
   11               "fields": [
   12                 { "id": 101, "label": "Текст отчета", "fieldType": "text", "isRequired": true, "display_order": 1 },
   13                 { "id": 102, "label": "Файл отчета", "fieldType": "file", "isRequired": false, "display_order": 2 }
   14               ]
   15             }
   16           ]
   17         }
       * Логика бэкенда: SELECT из template_versions, questionnaire_items, fields, собирает вложенный JSON.

  ---

  3. Задания (`/assignments`)

   * `POST /assignments`
       * Описание: Ручное назначение опросника одной или нескольким источникам.
       * Роль: MODERATOR
       * Пример запроса:

   1         {
   2           "name": "Еженедельный отчет - Волна 2",
   3           "templateId": 1,
   4           "sourceIds": [1, 2],
   5           "dueDate": "2026-04-01T00:00:00Z"
   6         }
       * Пример ответа (201 Created):
   1         {
   2           "message": "Assignments created successfully.",
   3           "createdCount": 2,
   4           "assignmentIds": [10, 11]
   5         }
       * Логика бэкенда: INSERT в assignments для каждого sourceId из массива.

   * `GET /assignments/my`
       * Описание: Получение списка заданий, доступных для источника текущего пользователя.
       * Роль: USER
       * Пример ответа (200 OK):

    1         [
    2           {
    3             "id": 1,
    4             "name": "Еженедельный отчет - 15 марта",
    5             "status": "IN_PROGRESS",
    6             "template": { "id": 1, "name": "Еженедельный отчет" },
    7             "assignee": { "id": 5, "fullName": "Иванов Иван" },
    8             "dueDate": "2026-03-22T00:00:00Z"
    9           },
   10           {
   11             "id": 10,
   12             "name": "Еженедельный отчет - Волна 2",
   13             "status": "LOCKED",
   14             "template": { "id": 1, "name": "Еженедельный отчет" },
   15             "assignee": null,
   16             "dueDate": "2026-04-01T00:00:00Z"
   17           }
   18         ]
       * Логика бэкенда: SELECT из assignments, JOIN с templates, users (для assignee), фильтрация по source_id пользователя.

   * `GET /assignments`
       * Описание: Получение списка всех заданий в системе (для модератора).
       * Роль: MODERATOR
       * Пример ответа (200 OK): (Массив объектов заданий, как в GET /my, но для всех источников).
       * Логика бэкенда: SELECT из assignments, JOIN с templates, users, sources.

   * `PUT /assignments/{assignmentId}`
       * Описание: Ручное изменение статуса задания модератором (например, для отмены).
       * Роль: MODERATOR
       * Пример запроса:

   1         {
   2           "status": "CANCELLED",
   3           "cancellationReason": "Срок истек, источник не заполнил."
   4         }
       * Пример ответа (200 OK):

   1         {
   2           "id": 1,
   3           "name": "Еженедельный отчет - 15 марта",
   4           "status": "CANCELLED",
   5           "cancellationReason": "Срок истек, источник не заполнил."
   6         }
       * Логика бэкенда: UPDATE assignments.

   * `POST /assignments/unlock`
       * Описание: Массовая активация (разблокировка) заданий.
       * Роль: MODERATOR
       * Пример запроса:

   1         {
   2           "assignmentIds": [1, 10]
   3         }
       * Пример ответа (200 OK):

   1         {
   2           "unlockedCount": 2,
   3           "message": "Задания успешно активированы."
   4         }
       * Логика бэкенда: UPDATE assignments SET status = 'PENDING' WHERE id IN (...) AND status = 'LOCKED'.

   * `POST /assignments/{assignmentId}/claim`
       * Описание: "Взять в работу" задание, доступное для источника.
       * Роль: USER
       * Пример ответа (200 OK):



   1         {
   2           "id": 1,
   3           "name": "Еженедельный отчет - 15 марта",
   4           "status": "IN_PROGRESS",
   5           "assignee": { "id": 5, "fullName": "Иванов Иван" }
   6         }
       * Логика бэкенда: UPDATE assignments SET status = 'IN_PROGRESS', assignee_user_id = <userId> WHERE id = {assignmentId} AND status = 
         'PENDING'.

  ---

  4. Файлы (`/files`)

   * `POST /files/upload`
       * Описание: Служебный эндпоинт для загрузки одного файла.
       * Роль: USER
       * Пример запроса: multipart/form-data с полем file.
       * Пример ответа (201 Created):

   1         {
   2           "filePath": "a1b2c3d4-e5f6-7890-abcd.pdf",
   3           "originalFilename": "отчет.pdf"
   4         }
       * Логика бэкенда: Сохраняет файл на диск, возвращает filePath.

  ---

  5. Заполнения и Ответы (`/submissions`, `/answers`)

   * `POST /submissions`
       * Описание: Отправка заполненной формы на проверку.
       * Роль: USER
       * Пример запроса:

   1         {
   2           "assignmentId": 1,
   3           "versionId": 1,
   4           "status": "SUBMITTED",
   5           "answers": [
   6             { "fieldId": 101, "textAnswer": "На этой неделе выполнено 5 задач." },
   7             { "fieldId": 102, "file": { "filePath": "abc-123.pdf", "originalFilename": "отчет.pdf" } }
   8           ]
   9         }
       * Пример ответа (201 Created):
   1         {
   2           "id": 501,
   3           "status": "SUBMITTED"
   4         }
       * Логика бэкенда: INSERT в submissions, INSERT в answers (для каждого ответа).

   * `GET /submissions/{submissionId}`
       * Описание: Универсальный эндпоинт для просмотра состояния конкретного заполнения.
       * Роль: USER, MODERATOR
       * Пример ответа (200 OK):

    1         {
    2           "id": 501,
    3           "status": "SUBMITTED",
    4           "user": { "id": 5, "fullName": "Иванов Иван" },
    5           "template": { "id": 1, "name": "Еженедельный отчет", "versionNumber": 1 },
    6           "items": [
    7             {
    8               "id": 10,
    9               "title": "Задачи на неделю",
   10               "answers": [
   11                 { "id": 801, "field": { "id": 101, "label": "Текст отчета" }, "textAnswer": "На этой неделе выполнено 5 задач.",
      "validationStatus": "PENDING" },
   12                 { "id": 802, "field": { "id": 102, "label": "Файл отчета" }, "file": { "originalFilename": "отчет.pdf", "downloadUrl":
      "/api/v1/submissions/501/answers/802/file" }, "validationStatus": "PENDING" }
   13               ]
   14             }
   15           ]
   16         }
       * Логика бэкенда: SELECT из submissions, answers, fields, questionnaire_items, users. Конструирует downloadUrl.

   * `PUT /submissions/{submissionId}`
       * Описание: Обновление статуса заполнения (например, модератором на APPROVED или REJECTED, или пользователем при повторной отправке).
       * Роль: USER, MODERATOR
       * Пример запроса (Модератор утверждает):
   1         {
   2           "status": "APPROVED"
   3         }
       * Пример ответа (200 OK):

   1         {
   2           "id": 501,
   3           "status": "APPROVED"
   4         }
       * Логика бэкенда: UPDATE submissions. Если status = APPROVED, то также UPDATE assignments.status на COMPLETED.

   * `POST /answers/{answerId}/validate`
       * Описание: Валидация модератором одного конкретного ответа.
       * Роль: MODERATOR
       * Пример запроса:

   1         {
   2           "status": "REJECTED",
   3           "comment": "Файл не подписан."
   4         }
       * Пример ответа (200 OK):

   1         {
   2           "id": 802,
   3           "validationStatus": "REJECTED",
   4           "moderatorComment": "Файл не подписан."
   5         }
       * Логика бэкенда: UPDATE answers (меняет validation_status и moderator_comment).


   * `GET /api/v1/submissions/{submissionId}/answers/{answerId}/file`
       * Описание: Безопасное скачивание файла, прикрепленного к ответу.
       * Роль: USER, MODERATOR
       * Пример ответа (200 OK): Бинарные данные файла.
       * Логика бэкенда: Проверяет аутентификацию и авторизацию пользователя. Если права есть, читает файл с диска и стримит его клиенту.

  ---

  6. Аудит (`/audit-logs`)

   * `GET /audit-logs`
       * Описание: Получение списка всех важных событий в системе.
       * Роль: ADMIN
       * Пример ответа (200 OK):

    1         [
    2           {
    3             "id": 1234,
    4             "user": { "id": 101, "fullName": "Петров Петр" },
    5             "action": "SUBMISSION_STATUS_UPDATED",
    6             "targetEntity": "submissions",
    7             "targetId": 501,
    8             "details": { "from": "SUBMITTED", "to": "APPROVED" },
    9             "createdAt": "2026-03-22T15:30:00Z"
   10           }
   11         ]
       * Логика бэкенда: SELECT из audit_logs, JOIN с users, фильтрация по параметрам.

  ---

  Это полная и детализированная спецификация API. Она включает все эндпоинты, их назначение, примеры запросов и ответов, а также краткое описание
  логики бэкенда.



================================================================================================
